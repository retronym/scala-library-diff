package scala.collection.immutable
trait Map[A, +B] extends scala.AnyRef with scala.collection.immutable.Iterable[scala.Tuple2[A, B]] with scala.collection.Map[A, B] with scala.collection.immutable.MapLike[A, B, scala.collection.immutable.Map[A, B]] {
 this: scala.collection.immutable.Map[A, B] =>
  def $init$(): scala.Unit = { /* compiled code */ }
  override def empty: scala.collection.immutable.Map[A, B] = { /* compiled code */ }
  @scala.deprecatedOverriding("Immutable maps should do nothing on toMap except return themselves cast as a map.")
  override def toMap[T, U](implicit ev: scala.Predef.<:<[scala.Tuple2[A, B], scala.Tuple2[T, U]]): scala.collection.immutable.Map[T, U] = { /* compiled code */ }
  override def seq: scala.collection.immutable.Map[A, B] = { /* compiled code */ }
  def withDefault[B1 >: B](d: scala.Function1[A, B1]): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
  def withDefaultValue[B1 >: B](d: B1): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
  override def updated[B1 >: B](key: A, value: B1): scala.collection.immutable.Map[A, B1]
  def +[B1 >: B](kv: scala.Tuple2[A, B1]): scala.collection.immutable.Map[A, B1]
}
object Map extends scala.collection.generic.ImmutableMapFactory[scala.collection.immutable.Map] {
  def this() = { /* compiled code */ }
  implicit def canBuildFrom[A, B]: scala.collection.generic.CanBuildFrom[scala.collection.generic.GenMapFactory.Coll, scala.Tuple2[A, B], scala.collection.immutable.Map[A, B]] = { /* compiled code */ }
  def empty[A, B]: scala.collection.immutable.Map[A, B] = { /* compiled code */ }
  class WithDefault[A, +B] extends scala.collection.Map.WithDefault[A, B] with scala.collection.immutable.Map[A, B] {
    def this(underlying: scala.collection.immutable.Map[A, B], d: scala.Function1[A, B]) = { /* compiled code */ }
    override def empty: scala.collection.immutable.Map.WithDefault[A, B] = { /* compiled code */ }
    override def updated[B1 >: B](key: A, value: B1): scala.collection.immutable.Map.WithDefault[A, B1] = { /* compiled code */ }
    override def +[B1 >: B](kv: scala.Tuple2[A, B1]): scala.collection.immutable.Map.WithDefault[A, B1] = { /* compiled code */ }
    override def -(key: A): scala.collection.immutable.Map.WithDefault[A, B] = { /* compiled code */ }
    override def withDefault[B1 >: B](d: scala.Function1[A, B1]): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    override def withDefaultValue[B1 >: B](d: B1): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
  }
  class Map1[A, +B] extends scala.collection.immutable.AbstractMap[A, B] with scala.collection.immutable.Map[A, B] with scala.Serializable {
    def this(key1: A, value1: B) = { /* compiled code */ }
    override def size: scala.Int = { /* compiled code */ }
    def get(key: A): scala.Option[B] = { /* compiled code */ }
    def iterator: scala.collection.Iterator[scala.Tuple2[A, B]] = { /* compiled code */ }
    override def updated[B1 >: B](key: A, value: B1): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def +[B1 >: B](kv: scala.Tuple2[A, B1]): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def -(key: A): scala.collection.immutable.Map[A, B] = { /* compiled code */ }
    override def foreach[U](f: scala.Function1[scala.Tuple2[A, B], U]): scala.Unit = { /* compiled code */ }
  }
  class Map2[A, +B] extends scala.collection.immutable.AbstractMap[A, B] with scala.collection.immutable.Map[A, B] with scala.Serializable {
    def this(key1: A, value1: B, key2: A, value2: B) = { /* compiled code */ }
    override def size: scala.Int = { /* compiled code */ }
    def get(key: A): scala.Option[B] = { /* compiled code */ }
    def iterator: scala.collection.Iterator[scala.Tuple2[A, B]] = { /* compiled code */ }
    override def updated[B1 >: B](key: A, value: B1): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def +[B1 >: B](kv: scala.Tuple2[A, B1]): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def -(key: A): scala.collection.immutable.Map[A, B] = { /* compiled code */ }
    override def foreach[U](f: scala.Function1[scala.Tuple2[A, B], U]): scala.Unit = { /* compiled code */ }
  }
  class Map3[A, +B] extends scala.collection.immutable.AbstractMap[A, B] with scala.collection.immutable.Map[A, B] with scala.Serializable {
    def this(key1: A, value1: B, key2: A, value2: B, key3: A, value3: B) = { /* compiled code */ }
    override def size: scala.Int = { /* compiled code */ }
    def get(key: A): scala.Option[B] = { /* compiled code */ }
    def iterator: scala.collection.Iterator[scala.Tuple2[A, B]] = { /* compiled code */ }
    override def updated[B1 >: B](key: A, value: B1): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def +[B1 >: B](kv: scala.Tuple2[A, B1]): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def -(key: A): scala.collection.immutable.Map[A, B] = { /* compiled code */ }
    override def foreach[U](f: scala.Function1[scala.Tuple2[A, B], U]): scala.Unit = { /* compiled code */ }
  }
  class Map4[A, +B] extends scala.collection.immutable.AbstractMap[A, B] with scala.collection.immutable.Map[A, B] with scala.Serializable {
    def this(key1: A, value1: B, key2: A, value2: B, key3: A, value3: B, key4: A, value4: B) = { /* compiled code */ }
    override def size: scala.Int = { /* compiled code */ }
    def get(key: A): scala.Option[B] = { /* compiled code */ }
    def iterator: scala.collection.Iterator[scala.Tuple2[A, B]] = { /* compiled code */ }
    override def updated[B1 >: B](key: A, value: B1): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def +[B1 >: B](kv: scala.Tuple2[A, B1]): scala.collection.immutable.Map[A, B1] = { /* compiled code */ }
    def -(key: A): scala.collection.immutable.Map[A, B] = { /* compiled code */ }
    override def foreach[U](f: scala.Function1[scala.Tuple2[A, B], U]): scala.Unit = { /* compiled code */ }
  }
}
