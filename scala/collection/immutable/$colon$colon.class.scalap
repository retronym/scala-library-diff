package scala.collection.immutable
@scala.SerialVersionUID { val value = 509929039250432923None }
final case class ::[B](head: B, tl: scala.collection.immutable.List[B]) extends scala.collection.immutable.List[B] with scala.Product with scala.Serializable {
  override val head: B = { /* compiled code */ }
  private[scala] var tl: scala.collection.immutable.List[B] = { /* compiled code */ }
  override def tail: scala.collection.immutable.List[B] = { /* compiled code */ }
  override def isEmpty: scala.Boolean = { /* compiled code */ }
  def copy[B](head: B, tl: scala.collection.immutable.List[B]): scala.collection.immutable.::[B] = { /* compiled code */ }
  def tl$1: scala.collection.immutable.List[B] = { /* compiled code */ }
  override def productPrefix: java.lang.String = { /* compiled code */ }
  def productArity: scala.Int = { /* compiled code */ }
  def productElement(x$1: scala.Int): scala.Any = { /* compiled code */ }
  override def productIterator: scala.collection.Iterator[scala.Any] = { /* compiled code */ }
}
object :: extends scala.AnyRef with scala.Serializable {
  def this() = { /* compiled code */ }
  final override def toString(): java.lang.String = { /* compiled code */ }
  def apply[B](head: B, tl: scala.collection.immutable.List[B]): scala.collection.immutable.::[B] = { /* compiled code */ }
  def unapply[B](x$0: scala.collection.immutable.::[B]): scala.Option[scala.Tuple2[B, scala.collection.immutable.List[B]]] = { /* compiled code */ }
}
