package scala.collection.convert
trait WrapAsJava extends scala.AnyRef {
  def $init$(): scala.Unit = { /* compiled code */ }
  implicit def asJavaIterator[A](it: scala.collection.Iterator[A]): java.util.Iterator[A] = { /* compiled code */ }
  implicit def asJavaEnumeration[A](it: scala.collection.Iterator[A]): java.util.Enumeration[A] = { /* compiled code */ }
  implicit def asJavaIterable[A](i: scala.collection.Iterable[A]): java.lang.Iterable[A] = { /* compiled code */ }
  implicit def asJavaCollection[A](it: scala.collection.Iterable[A]): java.util.Collection[A] = { /* compiled code */ }
  implicit def bufferAsJavaList[A](b: scala.collection.mutable.Buffer[A]): java.util.List[A] = { /* compiled code */ }
  implicit def mutableSeqAsJavaList[A](seq: scala.collection.mutable.Seq[A]): java.util.List[A] = { /* compiled code */ }
  implicit def seqAsJavaList[A](seq: scala.collection.Seq[A]): java.util.List[A] = { /* compiled code */ }
  implicit def mutableSetAsJavaSet[A](s: scala.collection.mutable.Set[A]): java.util.Set[A] = { /* compiled code */ }
  implicit def setAsJavaSet[A](s: scala.collection.Set[A]): java.util.Set[A] = { /* compiled code */ }
  implicit def mutableMapAsJavaMap[A, B](m: scala.collection.mutable.Map[A, B]): java.util.Map[A, B] = { /* compiled code */ }
  implicit def asJavaDictionary[A, B](m: scala.collection.mutable.Map[A, B]): java.util.Dictionary[A, B] = { /* compiled code */ }
  implicit def mapAsJavaMap[A, B](m: scala.collection.Map[A, B]): java.util.Map[A, B] = { /* compiled code */ }
  implicit def mapAsJavaConcurrentMap[A, B](m: scala.collection.concurrent.Map[A, B]): java.util.concurrent.ConcurrentMap[A, B] = { /* compiled code */ }
}
object WrapAsJava extends scala.AnyRef with scala.collection.convert.WrapAsJava {
  def this() = { /* compiled code */ }
}
