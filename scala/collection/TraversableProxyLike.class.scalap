package scala.collection
@scala.deprecated("Proxying is deprecated due to lack of use and compiler-level support.")
trait TraversableProxyLike[+A, +Repr <: scala.collection.TraversableLike[A, Repr] with scala.collection.Traversable[A]] extends scala.AnyRef with scala.collection.TraversableLike[A, Repr] with scala.Proxy {
  def $init$(): scala.Unit = { /* compiled code */ }
  def self: Repr
  override def foreach[B](f: scala.Function1[A, B]): scala.Unit = { /* compiled code */ }
  override def isEmpty: scala.Boolean = { /* compiled code */ }
  override def nonEmpty: scala.Boolean = { /* compiled code */ }
  override def size: scala.Int = { /* compiled code */ }
  override def hasDefiniteSize: scala.Boolean = { /* compiled code */ }
  override def ++[B >: A, That](xs: scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[Repr, B, That]): That = { /* compiled code */ }
  override def map[B, That](f: scala.Function1[A, B])(implicit bf: scala.collection.generic.CanBuildFrom[Repr, B, That]): That = { /* compiled code */ }
  override def flatMap[B, That](f: scala.Function1[A, scala.collection.GenTraversableOnce[B]])(implicit bf: scala.collection.generic.CanBuildFrom[Repr, B, That]): That = { /* compiled code */ }
  override def filter(p: scala.Function1[A, scala.Boolean]): Repr = { /* compiled code */ }
  override def filterNot(p: scala.Function1[A, scala.Boolean]): Repr = { /* compiled code */ }
  override def collect[B, That](pf: scala.PartialFunction[A, B])(implicit bf: scala.collection.generic.CanBuildFrom[Repr, B, That]): That = { /* compiled code */ }
  override def partition(p: scala.Function1[A, scala.Boolean]): scala.Tuple2[Repr, Repr] = { /* compiled code */ }
  override def groupBy[K](f: scala.Function1[A, K]): scala.collection.immutable.Map[K, Repr] = { /* compiled code */ }
  override def forall(p: scala.Function1[A, scala.Boolean]): scala.Boolean = { /* compiled code */ }
  override def exists(p: scala.Function1[A, scala.Boolean]): scala.Boolean = { /* compiled code */ }
  override def count(p: scala.Function1[A, scala.Boolean]): scala.Int = { /* compiled code */ }
  override def find(p: scala.Function1[A, scala.Boolean]): scala.Option[A] = { /* compiled code */ }
  override def foldLeft[B](z: B)(op: scala.Function2[B, A, B]): B = { /* compiled code */ }
  override def /:[B](z: B)(op: scala.Function2[B, A, B]): B = { /* compiled code */ }
  override def foldRight[B](z: B)(op: scala.Function2[A, B, B]): B = { /* compiled code */ }
  override def :\[B](z: B)(op: scala.Function2[A, B, B]): B = { /* compiled code */ }
  override def reduceLeft[B >: A](op: scala.Function2[B, A, B]): B = { /* compiled code */ }
  override def reduceLeftOption[B >: A](op: scala.Function2[B, A, B]): scala.Option[B] = { /* compiled code */ }
  override def reduceRight[B >: A](op: scala.Function2[A, B, B]): B = { /* compiled code */ }
  override def reduceRightOption[B >: A](op: scala.Function2[A, B, B]): scala.Option[B] = { /* compiled code */ }
  override def scanLeft[B, That](z: B)(op: scala.Function2[B, A, B])(implicit bf: scala.collection.generic.CanBuildFrom[Repr, B, That]): That = { /* compiled code */ }
  override def scanRight[B, That](z: B)(op: scala.Function2[A, B, B])(implicit bf: scala.collection.generic.CanBuildFrom[Repr, B, That]): That = { /* compiled code */ }
  override def sum[B >: A](implicit num: scala.Numeric[B]): B = { /* compiled code */ }
  override def product[B >: A](implicit num: scala.Numeric[B]): B = { /* compiled code */ }
  override def min[B >: A](implicit cmp: scala.Ordering[B]): A = { /* compiled code */ }
  override def max[B >: A](implicit cmp: scala.Ordering[B]): A = { /* compiled code */ }
  override def head: A = { /* compiled code */ }
  override def headOption: scala.Option[A] = { /* compiled code */ }
  override def tail: Repr = { /* compiled code */ }
  override def last: A = { /* compiled code */ }
  override def lastOption: scala.Option[A] = { /* compiled code */ }
  override def init: Repr = { /* compiled code */ }
  override def take(n: scala.Int): Repr = { /* compiled code */ }
  override def drop(n: scala.Int): Repr = { /* compiled code */ }
  override def slice(from: scala.Int, until: scala.Int): Repr = { /* compiled code */ }
  override def takeWhile(p: scala.Function1[A, scala.Boolean]): Repr = { /* compiled code */ }
  override def dropWhile(p: scala.Function1[A, scala.Boolean]): Repr = { /* compiled code */ }
  override def span(p: scala.Function1[A, scala.Boolean]): scala.Tuple2[Repr, Repr] = { /* compiled code */ }
  override def splitAt(n: scala.Int): scala.Tuple2[Repr, Repr] = { /* compiled code */ }
  override def copyToBuffer[B >: A](dest: scala.collection.mutable.Buffer[B]): scala.Unit = { /* compiled code */ }
  override def copyToArray[B >: A](xs: scala.Array[B], start: scala.Int, len: scala.Int): scala.Unit = { /* compiled code */ }
  override def copyToArray[B >: A](xs: scala.Array[B], start: scala.Int): scala.Unit = { /* compiled code */ }
  override def copyToArray[B >: A](xs: scala.Array[B]): scala.Unit = { /* compiled code */ }
  override def toArray[B >: A](implicit evidence$1: scala.reflect.ClassTag[B]): scala.Array[B] = { /* compiled code */ }
  override def toList: scala.List[A] = { /* compiled code */ }
  override def toIterable: scala.collection.Iterable[A] = { /* compiled code */ }
  override def toSeq: scala.collection.Seq[A] = { /* compiled code */ }
  override def toIndexedSeq: scala.collection.immutable.IndexedSeq[A] = { /* compiled code */ }
  override def toBuffer[B >: A]: scala.collection.mutable.Buffer[B] = { /* compiled code */ }
  override def toStream: scala.Stream[A] = { /* compiled code */ }
  override def toSet[B >: A]: scala.collection.immutable.Set[B] = { /* compiled code */ }
  override def toMap[T, U](implicit ev: scala.Predef.<:<[A, scala.Tuple2[T, U]]): scala.collection.immutable.Map[T, U] = { /* compiled code */ }
  override def toTraversable: scala.collection.Traversable[A] = { /* compiled code */ }
  override def toIterator: scala.collection.Iterator[A] = { /* compiled code */ }
  override def mkString(start: scala.Predef.String, sep: scala.Predef.String, end: scala.Predef.String): scala.Predef.String = { /* compiled code */ }
  override def mkString(sep: scala.Predef.String): scala.Predef.String = { /* compiled code */ }
  override def mkString: scala.Predef.String = { /* compiled code */ }
  override def addString(b: scala.collection.mutable.StringBuilder, start: scala.Predef.String, sep: scala.Predef.String, end: scala.Predef.String): scala.collection.mutable.StringBuilder = { /* compiled code */ }
  override def addString(b: scala.collection.mutable.StringBuilder, sep: scala.Predef.String): scala.collection.mutable.StringBuilder = { /* compiled code */ }
  override def addString(b: scala.collection.mutable.StringBuilder): scala.collection.mutable.StringBuilder = { /* compiled code */ }
  override def stringPrefix: scala.Predef.String = { /* compiled code */ }
  override def view: scala.AnyRef with scala.collection.TraversableView[A, Repr] = { /* compiled code */ }
  override def view(from: scala.Int, until: scala.Int): scala.collection.TraversableView[A, Repr] = { /* compiled code */ }
}
