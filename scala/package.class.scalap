package object scala extends scala.AnyRef {
  def this() = { /* compiled code */ }
  type Throwable = java.lang.Throwable
  type Exception = java.lang.Exception
  type Error = java.lang.Error
  type RuntimeException = java.lang.RuntimeException
  type NullPointerException = java.lang.NullPointerException
  type ClassCastException = java.lang.ClassCastException
  type IndexOutOfBoundsException = java.lang.IndexOutOfBoundsException
  type ArrayIndexOutOfBoundsException = java.lang.ArrayIndexOutOfBoundsException
  type StringIndexOutOfBoundsException = java.lang.StringIndexOutOfBoundsException
  type UnsupportedOperationException = java.lang.UnsupportedOperationException
  type IllegalArgumentException = java.lang.IllegalArgumentException
  type NoSuchElementException = java.util.NoSuchElementException
  type NumberFormatException = java.lang.NumberFormatException
  type AbstractMethodError = java.lang.AbstractMethodError
  type InterruptedException = java.lang.InterruptedException
  val AnyRef: scala.AnyRef with scala.Specializable = { /* compiled code */ }
  type TraversableOnce[+A] = scala.collection.TraversableOnce[A]
  type Traversable[+A] = scala.collection.Traversable[A]
  val Traversable: scala.collection.Traversable.type = { /* compiled code */ }
  type Iterable[+A] = scala.collection.Iterable[A]
  val Iterable: scala.collection.Iterable.type = { /* compiled code */ }
  type Seq[+A] = scala.collection.Seq[A]
  val Seq: scala.collection.Seq.type = { /* compiled code */ }
  type IndexedSeq[+A] = scala.collection.IndexedSeq[A]
  val IndexedSeq: scala.collection.IndexedSeq.type = { /* compiled code */ }
  type Iterator[+A] = scala.collection.Iterator[A]
  val Iterator: scala.collection.Iterator.type = { /* compiled code */ }
  type BufferedIterator[+A] = scala.collection.BufferedIterator[A]
  type List[+A] = scala.collection.immutable.List[A]
  val List: scala.collection.immutable.List.type = { /* compiled code */ }
  val Nil: scala.collection.immutable.Nil.type = { /* compiled code */ }
  type ::[A] = scala.collection.immutable.::[A]
  val ::: scala.collection.immutable.::.type = { /* compiled code */ }
  val +:: scala.collection.+:.type = { /* compiled code */ }
  val :+: scala.collection.:+.type = { /* compiled code */ }
  type Stream[+A] = scala.collection.immutable.Stream[A]
  val Stream: scala.collection.immutable.Stream.type = { /* compiled code */ }
  val #::: scala.collection.immutable.Stream.#::.type = { /* compiled code */ }
  type Vector[+A] = scala.collection.immutable.Vector[A]
  val Vector: scala.collection.immutable.Vector.type = { /* compiled code */ }
  type StringBuilder = scala.collection.mutable.StringBuilder
  val StringBuilder: scala.collection.mutable.StringBuilder.type = { /* compiled code */ }
  type Range = scala.collection.immutable.Range
  val Range: scala.collection.immutable.Range.type = { /* compiled code */ }
  type BigDecimal = scala.math.BigDecimal
  val BigDecimal: scala.math.BigDecimal.type = { /* compiled code */ }
  type BigInt = scala.math.BigInt
  val BigInt: scala.math.BigInt.type = { /* compiled code */ }
  type Equiv[T] = scala.math.Equiv[T]
  val Equiv: scala.math.Equiv.type = { /* compiled code */ }
  type Fractional[T] = scala.math.Fractional[T]
  val Fractional: scala.math.Fractional.type = { /* compiled code */ }
  type Integral[T] = scala.math.Integral[T]
  val Integral: scala.math.Integral.type = { /* compiled code */ }
  type Numeric[T] = scala.math.Numeric[T]
  val Numeric: scala.math.Numeric.type = { /* compiled code */ }
  type Ordered[T] = scala.math.Ordered[T]
  val Ordered: scala.math.Ordered.type = { /* compiled code */ }
  type Ordering[T] = scala.math.Ordering[T]
  val Ordering: scala.math.Ordering.type = { /* compiled code */ }
  type PartialOrdering[T] = scala.math.PartialOrdering[T]
  type PartiallyOrdered[T] = scala.math.PartiallyOrdered[T]
  type Either[+A, +B] = scala.util.Either[A, B]
  val Either: scala.util.Either.type = { /* compiled code */ }
  type Left[+A, +B] = scala.util.Left[A, B]
  val Left: scala.util.Left.type = { /* compiled code */ }
  type Right[+A, +B] = scala.util.Right[A, B]
  val Right: scala.util.Right.type = { /* compiled code */ }
}
